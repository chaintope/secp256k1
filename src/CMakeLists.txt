# Must be included before CMAKE_INSTALL_INCLUDEDIR is used.
include(GNUInstallDirs)

# Add objects explicitly rather than linking to the object libs to keep them
# from being exported.
add_library(secp256k1 secp256k1.c)
if(SECP256K1_ECMULT_STATIC_PRECOMPUTATION)
  target_sources(secp256k1 PRIVATE ecmult_static_context.h)
endif()

target_include_directories(secp256k1 
    PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/../include>
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>
    $<INSTALL_INTERFACE:include>
)

# Use the config file generated by the parent CMakeLists.txt
target_compile_definitions(secp256k1 PRIVATE HAVE_CONFIG_H SECP256K1_BUILD)

# We need to link in GMP
option(SECP256K1_USE_GMP "Use GMP for bignum operations" OFF)
set(has_gmp "no")

if(SECP256K1_USE_GMP)
    find_package(GMP)
    if(GMP_FOUND)
        set(has_gmp "yes")
        target_include_directories(secp256k1 PUBLIC ${GMP_INCLUDE_DIR})
        target_link_libraries(secp256k1 ${GMP_LIBRARY})
    else()
        message(FATAL_ERROR "GMP explicitly requested but not found")
    endif()
else()
    # Try to find GMP even if not explicitly requested (like autotools)
    find_package(GMP QUIET)
    if(GMP_FOUND)
        set(has_gmp "yes")
        target_include_directories(secp256k1 PUBLIC ${GMP_INCLUDE_DIR})
        target_link_libraries(secp256k1 ${GMP_LIBRARY})
    endif()
endif()

# Add module-specific compile definitions
if(SECP256K1_ENABLE_MODULE_ECDH)
    target_compile_definitions(secp256k1 PRIVATE ENABLE_MODULE_ECDH=1)
endif()

if(SECP256K1_ENABLE_MODULE_RECOVERY)
    target_compile_definitions(secp256k1 PRIVATE ENABLE_MODULE_RECOVERY=1)
    target_sources(secp256k1 PRIVATE modules/recovery/main_impl.h)
endif()

if(SECP256K1_ENABLE_MODULE_SCHNORR)
    target_compile_definitions(secp256k1 PRIVATE ENABLE_MODULE_SCHNORR=1)
    target_sources(secp256k1 PRIVATE modules/schnorr/main_impl.h)
endif()

# We make sure __int128 is defined
include(CheckTypeSize)
check_type_size(__int128 SIZEOF___INT128)
if(SIZEOF___INT128 EQUAL 16)
    target_compile_definitions(secp256k1 PRIVATE HAVE___INT128=1)
endif()

# Detect if we are on a 32 or 64 bits platform and choose
# scalar and field implementation accordingly
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    # 64 bits implementation requires either __int128 or asm support
    if(HAVE___INT128)
        target_compile_definitions(secp256k1 PRIVATE USE_SCALAR_4X64=1 USE_FIELD_5X52=1)
    elseif(SECP256K1_ASM STREQUAL "x86_64")
        include(CheckX86_64Assembly)
        check_x86_64_assembly()
        if(HAVE_X86_64_ASM)
            target_compile_definitions(secp256k1 PRIVATE USE_SCALAR_4X64=1 USE_FIELD_5X52=1)
        else()
            message(STATUS "x86_64 assembly requested but not available, falling back to 32-bit implementation")
            target_compile_definitions(secp256k1 PRIVATE USE_SCALAR_8X32=1 USE_FIELD_10X26=1)
        endif()
    else()
        message(STATUS "No 64-bit implementation available, falling back to 32-bit implementation")
        target_compile_definitions(secp256k1 PRIVATE USE_SCALAR_8X32=1 USE_FIELD_10X26=1)
    endif()
else()
    target_compile_definitions(secp256k1 PRIVATE USE_SCALAR_8X32=1 USE_FIELD_10X26=1)
endif()

# Executable internal to secp256k1 need to have the HAVE_CONFIG_H define set.
# For convenience, we wrap this into a function.
function(link_secp256k1_internal NAME)
  target_link_libraries(${NAME} secp256k1)
  target_compile_definitions(${NAME} PRIVATE HAVE_CONFIG_H SECP256K1_BUILD)
endfunction(link_secp256k1_internal)

add_library(secp256k1_asm INTERFACE)
if(SECP256K1_ASM STREQUAL "arm32")
    add_library(secp256k1_asm_arm OBJECT EXCLUDE_FROM_ALL)
    target_sources(secp256k1_asm_arm PUBLIC
            asm/field_10x26_arm.s
    )
    target_sources(secp256k1 PRIVATE $<TARGET_OBJECTS:secp256k1_asm_arm>)
    target_link_libraries(secp256k1_asm INTERFACE secp256k1_asm_arm)
endif()

if(WIN32)
    # Define our export symbol only for shared libs.
    set_target_properties(secp256k1 PROPERTIES DEFINE_SYMBOL SECP256K1_DLL_EXPORT)
    target_compile_definitions(secp256k1 INTERFACE $<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:SECP256K1_STATIC>)
endif()

# Object libs don't know if they're being built for a shared or static lib.
# Grab the PIC property from secp256k1 which knows.
get_target_property(use_pic secp256k1 POSITION_INDEPENDENT_CODE)


# This emulates Libtool to make sure Libtool and CMake agree on the ABI version,
# see below "Calculate the version variables" in build-aux/ltmain.sh.
math(EXPR ${PROJECT_NAME}_soversion "${${PROJECT_NAME}_LIB_VERSION_CURRENT} - ${${PROJECT_NAME}_LIB_VERSION_AGE}")
set_target_properties(secp256k1 PROPERTIES
        SOVERSION ${${PROJECT_NAME}_soversion}
)
if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    set_target_properties(secp256k1 PROPERTIES
            VERSION ${${PROJECT_NAME}_soversion}.${${PROJECT_NAME}_LIB_VERSION_AGE}.${${PROJECT_NAME}_LIB_VERSION_REVISION}
    )
elseif(APPLE)
    if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.17)
        math(EXPR ${PROJECT_NAME}_compatibility_version "${${PROJECT_NAME}_LIB_VERSION_CURRENT} + 1")
        set_target_properties(secp256k1 PROPERTIES
                MACHO_COMPATIBILITY_VERSION ${${PROJECT_NAME}_compatibility_version}
                MACHO_CURRENT_VERSION ${${PROJECT_NAME}_compatibility_version}.${${PROJECT_NAME}_LIB_VERSION_REVISION}
        )
        unset(${PROJECT_NAME}_compatibility_version)
    elseif(BUILD_SHARED_LIBS)
        message(WARNING
                "The 'compatibility version' and 'current version' values of the DYLIB "
                "will diverge from the values set by the GNU Libtool. To ensure "
                "compatibility, it is recommended to upgrade CMake to at least version 3.17."
        )
    endif()
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    set(${PROJECT_NAME}_windows "secp256k1")
    if(MSVC)
        set(${PROJECT_NAME}_windows "${PROJECT_NAME}")
    endif()
    set_target_properties(secp256k1 PROPERTIES
            ARCHIVE_OUTPUT_NAME "${${PROJECT_NAME}_windows}"
            RUNTIME_OUTPUT_NAME "${${PROJECT_NAME}_windows}-${${PROJECT_NAME}_soversion}"
    )
    unset(${PROJECT_NAME}_windows)
endif()
unset(${PROJECT_NAME}_soversion)

if(SECP256K1_BUILD_TESTS)
    include(TestSuite)
    create_test_suite(secp256k1)

    function(create_secp256k1_test NAME FILES)
        add_test_to_suite(secp256k1 ${NAME} ${FILES})
        link_secp256k1_internal(${NAME})
        set_tests_properties(${NAME} PROPERTIES
            WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/bin
        )
    endfunction()

    create_secp256k1_test(test_secp256k1 tests.c)
    target_compile_definitions(test_secp256k1 PRIVATE VERIFY)

    create_secp256k1_test(exhaustive_test_secp256k1 tests_exhaustive.c)
    # This should not be enabled at the same time as coverage is.
    # TODO: support coverage.
    target_compile_definitions(exhaustive_test_secp256k1 PRIVATE VERIFY)
endif()

if(SECP256K1_BUILD_BENCHMARK)
    add_executable(bench_sign bench_sign.c)
    link_secp256k1_internal(bench_sign)
    add_executable(bench_verify bench_verify.c)
    link_secp256k1_internal(bench_verify)
    add_executable(bench_internal bench_internal.c)
    link_secp256k1_internal(bench_internal)
    add_executable(bench_ecdh bench_ecdh.c)
    link_secp256k1_internal(bench_ecdh)
    add_executable(bench_recover bench_recover.c)
    link_secp256k1_internal(bench_recover)
endif()

if(SECP256K1_INSTALL)
    install(TARGETS secp256k1
            EXPORT ${PROJECT_NAME}-targets
            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    )
    set(${PROJECT_NAME}_headers
            "${PROJECT_SOURCE_DIR}/include/secp256k1.h"
            "${PROJECT_SOURCE_DIR}/include/secp256k1_preallocated.h"
    )
    if(SECP256K1_ENABLE_MODULE_ECDH)
        list(APPEND ${PROJECT_NAME}_headers "${PROJECT_SOURCE_DIR}/include/secp256k1_ecdh.h")
    endif()
    if(SECP256K1_ENABLE_MODULE_RECOVERY)
        list(APPEND ${PROJECT_NAME}_headers "${PROJECT_SOURCE_DIR}/include/secp256k1_recovery.h")
    endif()
    if(SECP256K1_ENABLE_MODULE_SCHNORR)
        list(APPEND ${PROJECT_NAME}_headers "${PROJECT_SOURCE_DIR}/include/secp256k1_schnorr.h")
    endif()
    install(FILES ${${PROJECT_NAME}_headers}
            DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
    )

    install(EXPORT ${PROJECT_NAME}-targets
            FILE ${PROJECT_NAME}-targets.cmake
            NAMESPACE ${PROJECT_NAME}::
            DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
    )

    include(CMakePackageConfigHelpers)
    configure_package_config_file(
            ${PROJECT_SOURCE_DIR}/cmake/config.cmake.in
            ${PROJECT_NAME}-config.cmake
            INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
            NO_SET_AND_CHECK_MACRO
    )
    write_basic_package_version_file(${PROJECT_NAME}-config-version.cmake
            COMPATIBILITY SameMinorVersion
    )

    install(
            FILES
            ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake
            ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
            DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
    )

    include(GeneratePkgConfigFile)
    generate_pkg_config_file(${PROJECT_SOURCE_DIR}/libsecp256k1.pc.in)
    install(
            FILES
            ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.pc
            DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig
    )
endif()
